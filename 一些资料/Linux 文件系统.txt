待做事情：
    1. LVM的详细操作， 比如：
        如何创建、增加、删除、修改 pv、vg、lv。
        如何互相移动：
            如何将一个lv移动到另一个vg中去
            如何将一个pv移动到另一个vg中去
        

先谈谈一个事：物理磁盘到文件系统
  盘片、扇区、磁道|柱面、磁头
    文件最终是保存在硬盘上的。
    硬盘最基本的组成部分是由坚硬金属材料制成的涂以磁性介质的盘片，不同容量硬盘的盘片数不等。
    每个盘片有两面，都可记录信息。
        盘片被分成许多扇形的区域，每个区域叫一个扇区，
            每个扇区可存储128×2的N次方（N＝0.1.2.3）字节信息。 == 簇
            在DOS中每扇区是128×2的2次方＝512字节。
    盘片表面上以盘片中心为圆心，不同半径的同心圆称为磁道。
        硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面。
        磁道与柱面都是表示不同半径的圆，在许多场合，磁道和柱面可以互换使用。
    每个磁盘有两个面，每个面都有一个磁头，习惯用磁头号来区分。
    扇区，磁道（或柱面）和磁头数构成了硬盘结构的基本参数，这些参数可以得到硬盘的容量，
        基计算公式为：
            存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数
    所以：
        信息记录可表示为：××磁道（柱面），××磁头，××扇区
    Liux怎么管理？ 
        磁盘块分为以下三个部分：
        1. 超级块，文件系统中第一个块被称为超级块。
            这个块存放文件系统本身的结构信息。
            比如，超级块记录了每个区域的大小，超级块也存放未被使用的磁盘块的信息。
        2. I-切点表。超级块的下一个部分就是i-节点表。
            每个i-节点就是一个对应一个文件/目录的结构，
            这个结构它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。
            一个文件系统维护了一个索引节点的数组，
                每个文件或目录都与索引节点数组中的唯一一个元素对应。
            系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号。
        3. 数据区。文件系统的第3个部分是数据区。
            文件的内容保存在这个区域。磁盘上所有块的大小都一样。
            如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。
            一个较大的文件很容易分布上千个独产的磁盘块中。
    Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。
        目录项:包括文件名和inode节点号。
        Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。
        数据块：文件的具体内容存放地。
    Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出
        目录块、inode Table区块和data block数据区域。
        一个文件由一个目录项、inode和数据区域块组成。
        Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。
        当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据。

Linux 文件系统
目的： 如何扩容
** Linux 中：
    一切皆文件； 若非文件则为进程。 
    具体含义：
        1. 将文件和目录视等同视之。 
            因为目录只是一个包含了其他文件名的文件而已。
            程序、服务、文本、图片等等，都是文件。
        2. 一切资源都是文件，包括硬件设备，称之为设备文件。
            对于系统来说，输入和输出设备，基本上所有的设备，都被当做是文件。
        3. 一个文件每次只做一件事。
    参看 Linux File System Hierarchy V2.0 图
        LINUX文件系统标准（Linux File System Standard,FSSTND）于1994年完成，
            规划了存放在LINUX文件系统中的目录以及使用方法。
    一些例外：
        1. 目录:由其他文件组成的文件
        2. 特殊文件:用于输入和输出的途径。
            大多数特殊文件都储存在/dev中。
        3. 链接文件:
            让文件或者目录出现在系统文件树结构上多个地方的机制。
        4. (域)套接字:特殊的文件类型
            和TCP/IP协议中的套接字有点像，提供进程间网络通讯，
            并受文件系统的访问控制机制保护。
        5. 命名管道 : 或多或少有点像sockets(套接字)，
            提供一个进程间的通信机制，而不用网络套接字协议。
            
0. 主要介绍：
    1. 两个命令
    2. 扩充的需求
    3. LVM 扩容
    
1. 两个命令： df & du 
    1. df 命令：root & icss 都一样可以用， 结果也相同。
        命令查看磁盘的分区和已经使用量
        df是读取整个文件系统中的superblock中的数据来输出的，所以速度很快。
        df 是来自coreutils 软件包，系统内置的；
        可以查看磁盘的使用情况以及文件系统被挂载的位置。
            文件系统？挂载位置？
        df -h
        df -lh      单机情况，二者一样。 -l 表示只看本机本地的文件系统情况。
        第一行中某些字段的含义：
            文件系统：代表磁盘的分区和内存中的某一个区域。
            容量：磁盘总共的容量
            已用：磁盘已经使用的容量
            可用：磁盘未使用的容量
            挂载点：该文件系统挂载在哪一个目录下
        注意！
            上面的磁盘，是我们的概念，其实应该分区。
    == 现在有四个概念：
        磁盘、分区、文件系统、挂载点
        下面若干行：
            1. udev、tmps等是系统运行时，在内存划分的一部分区域。
                这部分区域被临时挂载到文件树下。
            2. /dev/sr0 是光驱
            3. /dev/sda1 设备、s(csi)接口的第a(1)个硬盘(d)上的第1个分区
                问题： 如果是ide接口的硬盘，名称是什么样子的？
            4. /dev/mapper/centos-root
                == 具体：
                1. /dev/mapper/
                     Device mapper是Linux2.6内核中提供的一种从逻辑设备到物理设备的映射机制;
                     在该机制下，用户能够很方便的根据自己的需要实现对存储资源的管理。
                     在具体管理时需要用到Linux下的逻辑卷管理器，
                     当前比较流行的逻辑卷管理器有 LVM2（Linux Volume Manager 2 version)、
                     EVMS(Enterprise Volume Management System)、
                     dmraid(Device Mapper Raid Tool)等。
                     ** 查看本机的LVM命令：rpm -qa | grep lvm
                     可以参考：
                        https://www.ibm.com/developerworks/cn/linux/l-devmapper/
                    后面主要说的就是lvm
                    /*
                        简单理解下：
                            假设一台服务器有三块硬盘分别为a，b，c，每块硬盘的容量为1T。
                            在安装Linux的时候，先根据系统及自身的需要建立基本的分区，
                            假设对硬盘a进行了分区，分出去了0.1T的空间挂载在/boot目录下，
                            其他硬盘未进行分区。
                            系统利用Device mapper机制建立了一个卷组（volume group，VG），可以把VG当做一个资源池来看待，
                             最后在VG上面再创建逻辑卷（logical volume，LV）。
                             若要将硬盘a的剩余空间、硬盘b和硬盘c都加入到VG中，
                             则硬盘a的剩余空间首先会被系统建立为一个物理卷（physical volume，PV），并且这个物理卷的大小就是0.9T，
                             之后硬盘a的剩余的空间、硬盘b和硬盘c以PV的身份加入到VG这个资源池中，
                             然后你需要多大的空间，就可以从VG中划出多大的空间
                             （当然最大不能超过VG的容量）。
                             比如此时池中的空间就是2.9T，此时你就可以建立一个1T以上的空间出来，
                             而不像以前最大的容量空间只能为1T。
                         即：LVM包含VG，PV，LV
                    */
                2. /centos-root
                    centos：一个VG (volume group卷组)叫作centos
                    root：这个centos里面有一个LV叫作lv_root
                == 几个和lvm相关的命令
                    fdisk -l
                    vgdisplay
                    pvdisplay
                    lvdisplay
                    ll /dev/mapper/centos-root
                         其实在系统里
                         /dev/centos/root 、 
                         /dev/mapper/centos-root 、
                         /dev/dm-0都是一个东西，都可当作一个分区来对待
                总结：
                    使用用LVM管理，sda2作为PV，建了VG centos，在上面建了LV root
                        然后lv上做了文件系统，挂载点为 / 
                    disk - partition - Volume(LV) - FileSystem -  MountPoint
                先这么看。先理解到这里。
            综上，我们知道什么？
                disk - partition - Volume
                两个挂载点
                    /boot   文件系统中的 /boot
                    /       文件系统的 /
                可是、可是： 在 LFSH中 / 下包含 /boot ???
                        

    2. du 命令
        命令查询当前目录下的所有目录/文件所占的容量
        左侧是占据的容量，右侧是具体的文件名/目录名。
            -a  显示对涉及到的所有文件的统计，而不只是包含子目录。
            -h  为每个数附加一个表示大小单位的字母，象用M表示二进制 的兆字节。
            -x  只输出指定参数的实际使用空间，而不包括其下的子目录。
        常用 
            du -h
            du -ah
    
2. 扩充的需求 
    0. .cache 文件夹   == 每个用户的主目录下均存在
        其中有两类文件夹：
        1. /vmware/drag_and_drop  注意：每个用户的主目录下都有。
            虚拟机在使用过程中，需要安装的软件是通过拖拽上传的安装包。
            由于虚拟机会缓存拖拽文件，不自动删除，导致系统占用空间越来越大。
            使用 rm -rf * 删除即可。
        2. 其他文件夹
            包含软件安装的缓存文件， 需要使用特定命令删除。
            * sudo apt-get autoclean      清理旧版本的软件缓存
            sudo apt-get clean          清理所有软件缓存
            * sudo apt-get autoremove     删除系统不再使用的孤立软件
            说明：
                linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具
                以其他身份来按照预设的身份执行命令，预设的身份为root。
                在/etc/sudoers中设置了可执行sudo指令的用户。
                若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。
                用户使用sudo时，先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。
                sudo的工作过程如下：
                    1. 当用户执行sudo时，系统会看/etc/sudoers文件，判断该用户是否有执行sudo的权限
                    2. 确认用户具有可执行sudo的权限后，让用户输入用户自己的密码确认
                    3. 若密码输入成功，则开始执行sudo后续的命令
                    4. root执行sudo时不需要输入密码
                        (eudoers文件中有配置root ALL=(ALL) ALL这样一条规则)
                    5. 若欲切换的身份与执行者的身份相同，也不需要输入密码
                个人建议：如果有root权限，就别用 sudo 命令。
    1. 扩充容量的过程：
        0. Dos & Windows 
            盘符其实是分区的名字，说C盘，其实不对。
            磁盘首先进行分区，每个分区都会获得一个字母标识符，就是盘符。
            可以选用这个字母来指定在这个分区上的文件和目录，它们的文件结构都是独立的。
                当然：分区也有类型，主分区、扩展分区(逻辑分区)...
            而且：
                对windows用户来说，操作系统必须装在同一分区里！
                即：作为引导和启动系统的分区(启动分区)必须是C。
            分区之后，进行格式化。格式化就是确定分区的类型 - 文件系统。
                Windows 文件系统：
                    FAT16：最大2G分区，单个分区最多65536个簇。
                        单簇为 512个字节的整数倍，最大为32KB。
                        所以： 65536 * 32K = 2G
                    FAT32：win98开始，最大分区2T，单个文件最大4G；
                    NTFS：windows NT&XP开始，有文件级的权限。 
                        记录文件操作日志，会产生多次读写，对固态硬盘&对U盘伤寿命。
                        单一分区&单一文件最大2T(?)
                            如果采用GPT，没有限制。 只有MBR分区才有最大2T的容量限制。
                    == GPT（GUID Partition Table）分区和MBR（Master Boot Record）分区
                        最先Windows8，GPT是一种新的硬盘分区标准，最大支持18EB容量
                        MBR，“主引导记录”，最大只支持2TB，兼容性好。
                    exFat：单一分区&单一文件最大16EB。簇最小512Byte，最大32M。
            但怎么扩容呢？
                只能换硬盘，拷贝文件。。。
            因此 Windows 引入 动态磁盘的概念。
                前面的三种分区都是静态磁盘的分区，就是容量不能动态的扩充。
            Windows 动态磁盘，有5种类型，叫 卷！
                卷：相当于在分区上给出一个逻辑层！！！
                1. 简单卷：构成单个物理磁盘空间的卷。
                    由磁盘上的单个区域或同一磁盘上连接在一起的多个区域组成，
                    可以在同一磁盘内扩展简单卷。 
                2. 跨区卷：简单卷也可以扩展到其它的物理磁盘。 
                    由多个物理磁盘的空间组成的卷就称为跨区卷。简单卷和跨区卷都不属于RAID。
                3. 带区卷：以带区形式在两个或多个物理磁盘上存储数据的卷。
                    带区卷上的数据被交替、平均（以带区形式）地分配给这些磁盘，
                    是可用的卷中性能最佳的，但它不提供容错。
                    带区卷可以看作硬件RAID中的RAID0。 
                4. 镜像卷：在两个物理磁盘上复制数据的容错卷。
                    它通过使用卷的副本（镜像）复制该卷中的信息来提供数据冗余，
                        镜像总位于另一个磁盘上。
                    如果其中一个物理磁盘出现故障，则该故障磁盘上的数据将不可用，
                        但是系统可以使用未受影响的磁盘继续操作。
                    镜像卷可以看作硬件RAID中的RAID1。 
                5. RAID－5卷：具有数据和奇偶校验的容错卷。
                    分布于三个或更多的物理磁盘，奇偶校验用于在阵列失效后重建数据。
                        如果物理磁盘的某一部分失败，
                        可以用余下的数据和奇偶校验信息重新创建磁盘上失败的那一部分上的数据。
                    类似硬件RAID中的RAID5。
        1. Linux 的磁盘、分区、文件系统
            Linux就很乱:
                对linux用户来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根(/)目录，
                一个独立且唯一的文件结构，咋办？？？
                Linux系统中，有且仅有一个盘符，“/”。(在安装linux系统时，这个“/”目录必须划分)
                    其他的分区，只能通过在根分区新建各种不同的文件夹来进行访问。
                    1.  linux中每个分区都是用来组成整个文件系统的一部分，
                    2. 采用了一种叫“挂载-Mount == 挂载点-MountPoint”的处理方法
                        它的整个文件系统中包含了一整套的文件和目录，
                        且将一个分区和一个目录联系起来。
                        这时要载入的一个分区将从它的存储空间在一个目录下获得。
                    3. 比如前面的 /boot 分区，他是挂载在根目录(/)下的一个目录。
                        在系统启动的时候，会把此目录下的文件，挂载在/boot 下完成系统引导启动。
                            就是 Linux 下的MBR。
            0. 硬盘 & 分区
                硬盘的分区主要分为主分区（primary partion）和扩展分区(extension partion)两种
                    主分区和扩展分区的数目之和不能大于四个。
                    且主分区可以马上使用但不能再分区。
                    扩充分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。
                    扩充分区再分就是逻辑分区（logical partion），逻辑分区没有数量上限制。
            1. Linux 分区管理 = 设备管理
                在 Linux 中，每一个硬件设备都映射到一个系统的文件。
                     IDE 设备 hd 前缀； SCSI 设备 sd 前缀
                         ide硬盘，驱动器标识符为“hdx~”,
                            其中“hd”表明分区所在设备的类型。
                            “x”为盘号（a为第一个盘，b为第二盘。。。）
                            “~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，
                            从5开始就是逻辑分区。
                            如： hda3、hdb2...
                        scsi硬盘则标识为“sdx~”, 类似上面。。。
                第一个 IDE 设备，Linux 就定义为 hda；第二个 IDE 设备就定义为 hdb；下面以此类推。
                    SCSI 设备就应该是 sda、sdb、sdc 等。
            2. Linux 分区管理 = 分区数量
                要进行分区就必须针对每磁盘(IDE|SCSI)进行操作。
                对于每一个硬盘（IDE|SCSI）设备，Linux 分配了一个 1 到 16 的序列号码，
                    代表了这块硬盘上面的分区号码。
　　              例如，第一个 IDE 硬盘的第一个分区，是 hda1，第二个分区就是 hda2。
                        SCSI 硬盘则是 sda1、sdb1 等。
            3. Linux 分区管理 = 分区数量
                Linux 规定，每一个硬盘前4个分区号码是主分区和扩展分区，
                    任何一个扩展分区都要占用一个1~4之间的分区号码。
                    也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。
            4. Linux 分区管理 = 主分区 可以认为是MBR
                主分区的作用就是计算机用来进行启动操作系统的
                每一个操作系统的启动，或者称作是引导程序，都应该存放在主分区上。
                    主分区和扩展分区及逻辑分区的最大区别。　　
                    引导 Linux 的 bootloader ，要指定在主分区上，就是/boot !!!
                        扩展得出的结论： 可以把一个分区挂载到一个目录下面！！！
                    /boot 137G的限制！！！
                        无法引导137GB之后的分区中的Linux内核。
                        所以，一般推荐：
                            在/boot目录上挂载一个大小为100MB左右的独立分区
                            并推荐把该/boot放在硬盘的前面——即1024柱面之前。
            5. Linux 分区管理 = 分区指标
                分区的大小、分区的类型
                    分区的类型规定了这个分区上面的文件系统的格式
                        通过分区类型号码来定义不同类型的分区。如：8e
            6. Linux 常用分区
                *1. / 根（root）分区
                    根分区是”/”（根目录）所在地（注意不是/root）。
                    只需要启动系统所须的文件和系统配置文件。
                    对于大多数系统，50MB到100MB的根分区可以工作得很好。 
                *2. /swap，交换分区，也是一种文件系统，
                    作为Linux的虚拟内存。
                    在Windows下，虚拟内存是一个文件：pagefile.sys；
                    Linux下，虚拟内存需要使用独立分区，目的是为了提高虚拟内存的性能。
                    最多2G 
                3. /home：是用户文件夹所在的地方。
                    用户的home目录所在地; 大小取决于Linux系统用户数，以及用户将存放多少数据。
                4. /usr分区, 系统存放软件的地方，尽可能大。
                    /usr是Linux系统的许多软件所在的地方。
                    如果可能，将最大的空间用于/usr分区。
                    以后将要安装的基于RPM的包都会使用比其他分区更多的/usr空间。
                5. /usr/local：是 Linux系统存放软件的地方
                6. /var分区。Linux系统将把日志写在/var/log，是系统日志记录分区
                    如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，
                        也不会影响到操作系统的主分区。
                    需要日志服务的服务器才需要这个分区设置大一些。
                7. /usr/src分区。
                    /usr/src通常存放两样东西： 一是Linux内核源程序、二是RPM包的源程序。
                8. /tmp分区用来存放临时文件，多用户系统或者网络服务器来说是有必要的。
                9. /bin分区，存放标准系统实用程序。
                10. /dev分区，存放设备文件。
                11. /opt分区，存放可选的安装的软件。
                12. /sbin分区，存放标准系统管理文件。
                13. /boot分区，包含了操作系统的内核和在启动系统过程中所要用到的文件，必须的。
                    单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够启动。
                        无法引导137GB之后的分区中的Linux内核，
                        如果想用lilo启动 linux系统的话，含有/boot的分区必须完全在柱面1023以下。
                        由于8gb后的数据lilo不能读取，所以linux要安装在8gb的区域以内。
                    推荐把该/boot放在硬盘的前面——即1024柱面之前。
            == 分区方案建议：
                查看本机的分区方案：
                    fdisk -l
                    ll /dev/mapper/
            == 交换分区 /swap SWAP分区一般大小为物理内存的2倍，但最大不超过2G；
                1. 查看 /swap 分区命令
                    fdisk -l
                    free -m     swap 空间大小(总计)
                    swapon -s   查看swap 空间(file(s)/partition(s))、包括 文件 和 分区 的详细信息
                        == cat /proc/swaps
                    ll /dev/mapper/
                2. 增加SWAP空间的方法有两个
                    1. 增加另外一个SWAP分区
                        创建SWAP分区 (添加一个硬盘、或者在现有空闲分区上分区，然后执行分区类型)
                             fdisk -l 
                             (m---p ---n --t (将分区类型转换成 82)--w)
                         == （假设 /dev/sdb2 是创建的交换分区）
                        格式化交换分区 
                             mkswap /dev/sdx~
                             mkswap /dev/sdb2
                        启用交换分区，加入swap池
                            swapon -a /dev/sdx~
                            swapon -a /dev/sdb2
                        查看结果：
                            swapon -s 或 free 或 cat /proc/swaps
                        从swap池中拿掉
                            swapoff /dev/sdx~
                            swapoff /dev/sdb2
                        写入/etc/fstab,以便在引导时启用：
                            echo "/dev/sdx~ swap swap defaults 0 0" >> /etc/fstab
                            echo "/dev/sdb2 swap swap defaults 0 0" >> /etc/fstab
                    2. 通过创建一个SWAP文件来实现
                        创建大小为512M的交换文件：
                            dd if=/dev/zero of=/tmp/tmp.swap bs=1024k count=512
                        使用 mkswap 命令来设置交换文件：
                            # mkswap /tmp/tmp.swap 
                        启用交换分区：
                            swapon /tmp/tmp.swap
                        写入/etc/fstab,以便在引导时启用：
                            /tmp/tmp.swap swap swap defaults 0 0
                        查看：
                            swapon -s 或free 或cat /proc/swaps 
                3. 删除SWAP分区
                    swapoff 。。。
                    修改/etc/fstab文件，删除。。。
                    视需要删除分区
            7. Linux 分区管理 = 分区格式|文件系统 
                查看当前文件系统
                    df -T
                Linux的文件系统（分区格式）主要有ext3、ReiserFS、XFS、JFS等。
                    同时Linux也可以读写使用FAT、FAT32和NTFS文件系统的分区。
                CentOS默认的文件系统是ext3。
                    默认的设置不一定是性能最好的，但对普通用户一定是最稳定最安全最适合的。
                最大分区大小：
                    ext3是4TB，ReiseFS是16TB
                    FAT32在Linux中的FAT32则可以支持到2TB。
                最大文件大小：
                    ext3是2GB~4GB，ReiseFS是8TB，FAT32是4GB。
                 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，
                 Ext4 分别支持 1EB的文件系统，以及 16TB 的文件.
                 Ext3 目前只支持 32,000 个子目录，而 Ext4 支持无限数量的子目录。
                格式化分区 = 就是确定分区的文件系统
                    mkfs -t 。。。默认ext2
                    但是多使用：
                        mkfs.XXX 如：
                            mkfs.ext3、mkfs.ext3、mkfs.ext4 ...
            总结：
                添加硬盘：可选
                    虚拟机(左侧)、右键“设置”、点击“硬盘”、点击“添加”
                    增加一块硬盘
                先分区
                    fdisk -l    查看可用设备、可用分区
                    fdisk /dev/sdx
                        fdisk /dev/sdb
                        m\p\n-p\t(0)\w
                格式化分区 
                    mkfs.extX /dev/sdx~
                        mkfs.ext4 /dev/sdb1
            ====至此， 其实和Windows 的非动态磁盘一样
                演示：
                    0. 扩展硬盘
                        扩展现有硬盘的空闲空间
                            虚拟机(左侧)、右键“设置”、点击“硬盘”、点击右侧“扩展”、增加空间
                        添加新的硬盘
                            虚拟机(左侧)、右键“设置”、点击“硬盘”、点击“添加”、增加一块硬盘
                    1. 分区 
                        Fdisk -l    看新设备、空闲分区
                            常用的 fdisk 命令。
                                n - 创建分区
                                p - 打印分区表
                                d - 删除一个分区
                                q - 不保存更改退出
                                w - 保存更改并退出
                    2. 格式化
                        mkfs.extX /dev/sdx~ 
                    3. 挂载：
                        先创建一个目录
                            mkdir /home/icss/data
                        挂载 
                            mount /dev/sdx~ /home/icss/data
                                mount /dev/sdb1 /home/icss/data
                        查看 
                            df -T
                            df -h
                    4. 在 /etc/fstab 文件中添加条目以便永久启动时自动挂载。
                        /dev/sdx~ /home/icss/data ext4 defaults 0 0
                            /dev/sdb1 /home/icss/data ext4 defaults 0 0
                        第一列为设备分区, 
                        第二列为挂载目录（该目录必须为空目录），
                        第三列为文件系统类型，
                        第四列为参数，defaults 默认挂载
                        第五列0表示不备份，
                        最后一列必须为２或0(除非引导分区为1)
                问题：
                    无法扩展！！！
                    如果扩展， 只能类似Windows那样，换盘|换分区，重新复制文件。
3. 使用用LVM， 完成硬盘的扩容
    0. 扩容方式
        1. 加分区、加硬盘
        2. 分区 
        3. 设置分区类型 - 卷
        4. 格式化分区
        5. 在现有的挂载点使用lvm进行扩充
            要求必须是LVM
/*
LVM中基本的概念：PV  VG LV 就是物理卷，卷组，逻辑卷。
PV： 就是物理设备构成，可以是一个分区，也可以是一个硬盘。
VG：是一个逻辑容器概念，同时包含了PV和LV。
PV的数量和大小决定了一个卷组，也就是VG的最终可用物理空间的容量。
LV：是逻辑概念，LV最为类似之前的分区，可以格式化成为文件系统来使用。
之前是这么用的：
    分区--> 文件系统
现在变成了：分区-->PV--VG---LV--文件系统
*/
    1. LVM - 看图
        LVM的产生是因为传统的分区一旦分区好后就无法在线扩充空间，
         传统的分区当分区空间不足时，
            一般的解决办法是再创建一个更大的分区将原分区卸载然后将数据拷贝到新分区，
        但是在企业的生产系统往往不允许停机或者允许停机的时间很短，
            LVM就能很好的解决在线扩充空间的问题，而且不会对数据造成影响，
            LVM还能通过快照在备份的过程中保证日志文件和表空间文件在同一时间点的一致性。
        LVM就是动态卷管理，可以将多个硬盘和硬盘分区做成一个逻辑卷，
            并把这个逻辑卷作为一个整体来统一管理，动态对分区进行扩缩空间大小，安全快捷方便管理。
        LVM有几个概念，
            PV（Physical Volume，物理卷）
                从磁盘分区中直接创建；
            VG（Volume Group，卷组）
                VG是一个容器的概念，它可以包含若干个逻辑卷，可以将若干个物理卷加入到卷组，
                由卷组统一分配空间；
            LV（Logical Volume，逻辑卷）
                LV是直接面向用户的概念
        简单的来讲：
            就是使用实际的磁盘分区创建物理卷，
            然后将物理卷加入到卷组，
                可以认为卷组是一个相当于其中所有物理卷大小之和的未分配的分区，
            然后卷组再创建若干个逻辑卷，再将空间分配给逻辑卷。
    2. 具体的扩容
su - root
df -h 
fdisk -l 
1. fdisk
fdisk /dev/sda
	p　　
	n　　
	p　　
	3　　
	回车　
	回车　
	t　　
	3　　
	8e　　
	w　　
	q　　
	
2. shutdown -r now

3. mkfs.ext3 /dev/sda3

4. lvm 
	pvcreate /dev/sda3
	vgextend centos /dev/sda3 
	lvextend -L +4G /dev/mapper/centos-root
	pvdisplay
	quit
	
5. 
resize2fs /dev/mapper/centos-root
xfs_growfs /dev/mapper/centos-root

                        


        fdisk -l :查看系统中都认到了那些物理硬盘
        pvdisplay:查看系统中已经创建好的物理卷
        pvcreate:创建一个新的物理卷
        pvremove:删除一个物理卷(也就是从物理卷中删除一个LVM标签)
        vgdisplay:查看系统中的卷组
        vgcreate:创建一个新的卷组
        vgreduce:从卷组中删除一个物理卷(也就是缩小卷组)
        vgremove:删除一个卷组
        lvdisplay:查看系统中已经创建好的逻辑卷
        lvcreate:创建一个新的逻辑卷
        lvreduce:缩小逻辑卷(也就是从一个逻辑卷中减少一些LE)
        lvremove:从系统中删除一个逻辑卷
        mkfs:基于逻辑卷创建一个相应类型的文件系统
        mkdir -p $mount_piont:创建一个挂载目录

        resize2fs: 将分配好的逻辑卷的空间实际应用到文件系统中







目录	描述
/ 	主层次 的根，也是整个文件系统层次结构的根目录
/bin 	存放在单用户模式可用的必要命令二进制文件，所有用户都可用，如 cat、ls、cp等等
/boot 	存放引导加载程序文件，例如kernels、initrd等
/dev 	存放必要的设备文件，例如/dev/null
/etc 	存放主机特定的系统级配置文件。其实这里有个关于它名字本身意义上的的争议。在贝尔实验室的UNIX实施文档的早期版本中，/etc表示是“其他（etcetera）目录”，因为从历史上看，这个目录是存放各种不属于其他目录的文件（然而，文件系统目录标准 FSH 限定 /etc 用于存放静态配置文件，这里不该存有二进制文件）。早期文档出版后，这个目录名又重新定义成不同的形式。近期的解释中包含着诸如“可编辑文本配置”或者“额外的工具箱”这样的重定义
/etc/opt 	存储着新增包的配置文件 /opt/.
/etc/sgml 	存放配置文件，比如 catalogs，用于那些处理SGML(译者注：标准通用标记语言)的软件的配置文件
/etc/X11 	X Window 系统11版本的的配置文件
/etc/xml 	配置文件，比如catalogs，用于那些处理XML(译者注：可扩展标记语言)的软件的配置文件
/home 	用户的主目录，包括保存的文件，个人配置，等等
/lib 	/bin/ 和 /sbin/中的二进制文件的必需的库文件
/lib<架构位数> 	备用格式的必要的库文件。 这样的目录是可选的，但如果他们存在的话肯定是有需要用到它们的程序
/media 	可移动的多媒体(如CD-ROMs)的挂载点。(出现于 FHS-2.3)
/mnt 	临时挂载的文件系统
/opt 	可选的应用程序软件包
/proc 	以文件形式提供进程以及内核信息的虚拟文件系统，在Linux中，对应进程文件系统（procfs ）的挂载点
/root 	根用户的主目录
/sbin 	必要的系统级二进制文件，比如， init, ip, mount
/srv 	系统提供的站点特定数据
/tmp 	临时文件 (另见 /var/tmp). 通常在系统重启后删除
/usr 	二级层级存储用户的只读数据； 包含(多)用户主要的公共文件以及应用程序
/usr/bin 	非必要的命令二进制文件 (在单用户模式中不需要用到的)；用于所有用户
/usr/include 	标准的包含文件
/usr/lib 	库文件，用于/usr/bin/ 和 /usr/sbin/中的二进制文件
/usr/lib<架构位数> 	备用格式库(可选的)
/usr/local 	三级层次 用于本地数据，具体到该主机上的。通常会有下一个子目录, 比如, bin/, lib/, share/.
/usr/local/sbin 	非必要系统的二进制文件，比如用于不同网络服务的守护进程
/usr/share 	架构无关的 (共享) 数据.
/usr/src 	源代码，比如内核源文件以及与它相关的头文件
/usr/X11R6 	X Window系统，版本号:11，发行版本：6
/var 	各式各样的（Variable）文件，一些随着系统常规操作而持续改变的文件就放在这里，比如日志文件，脱机文件，还有临时的电子邮件文件
/var/cache 	应用程序缓存数据. 这些数据是由耗时的I/O(输入/输出)的或者是运算本地生成的结果。这些应用程序是可以重新生成或者恢复数据的。当没有数据丢失的时候，可以删除缓存文件
/var/lib 	状态信息。这些信息随着程序的运行而不停地改变，比如，数据库，软件包系统的元数据等等
/var/lock 	锁文件。这些文件用于跟踪正在使用的资源
/var/log 	日志文件。包含各种日志。
/var/mail 	内含用户邮箱的相关文件
/var/opt 	来自附加包的各种数据都会存储在 /var/opt/.
/var/run 	存放当前系统上次启动以来的相关信息，例如当前登入的用户以及当前运行的daemons(守护进程).
/var/spool 	该spool主要用于存放将要被处理的任务，比如打印队列以及邮件外发队列
/var/mail 	过时的位置，用于放置用户邮箱文件
/var/tmp 	存放重启后保留的临时文件


***********
参看：
    https://www.cnblogs.com/smartjourneys/p/7260911.html
    https://blog.csdn.net/xiaoyi23000/article/details/51345179
    https://blog.csdn.net/heikefangxian23/article/details/51579971
    https://blog.csdn.net/windxxf/article/details/909077
    https://blog.csdn.net/phoenix_wang_cheng/article/details/52743821
    https://blog.csdn.net/aaronychen/article/details/2270048
    https://blog.csdn.net/peter_jjh/article/details/55805041
    https://www.linuxidc.com/Linux/2016-01/127906.htm
    https://baike.baidu.com/item/LVM/6571177
    https://www.cnblogs.com/linuxprobe/p/5381538.html
    https://www.cnblogs.com/chenmh/p/5107901.html
    https://www.linuxprobe.com/one-picture-to-learn-lvm.html
    https://www.cnblogs.com/doomsword/p/3501877.html
    